"""
–£—Ç–∏–ª–∏—Ç—ã –¥–ª—è —Ä–∞–±–æ—Ç—ã —Å Telegram WebApp
"""
import json
import logging
from typing import Any, Dict, Optional

logger = logging.getLogger(__name__)


def diagnose_telegram_request(request) -> Dict[str, Any]:
    """
    –î–∏–∞–≥–Ω–æ—Å—Ç–∏–∫–∞ Telegram WebApp –∑–∞–ø—Ä–æ—Å–∞

    Args:
        request: HTTP –∑–∞–ø—Ä–æ—Å

    Returns:
        Dict —Å –¥–∏–∞–≥–Ω–æ—Å—Ç–∏—á–µ—Å–∫–æ–π –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π
    """
    diagnosis = {
        'is_telegram_request': False,
        'detection_methods': {},
        'raw_data': {},
        'parsed_data': {},
        'errors': [],
        'recommendations': []
    }

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º —Ä–∞–∑–ª–∏—á–Ω—ã–µ —Å–ø–æ—Å–æ–±—ã –æ–ø—Ä–µ–¥–µ–ª–µ–Ω–∏—è Telegram –∑–∞–ø—Ä–æ—Å–∞
    detection_methods = {
        'has_auth_param': bool(request.GET.get('_auth') or request.POST.get('_auth')),
        'has_tgWebAppData': bool(request.GET.get('tgWebAppData') or request.POST.get('tgWebAppData')),
        'user_agent_telegram': 'Telegram' in request.META.get('HTTP_USER_AGENT', ''),
        'has_telegram_secret_token': 'X-Telegram-Bot-Api-Secret-Token' in request.META,
        'referer_telegram': any(domain in request.META.get('HTTP_REFERER', '')
                                for domain in ['web.telegram.org', 'webk.telegram.org', 'webz.telegram.org']),
    }

    diagnosis['detection_methods'] = detection_methods
    diagnosis['is_telegram_request'] = any(detection_methods.values())

    # –°–æ–±–∏—Ä–∞–µ–º —Å—ã—Ä—ã–µ –¥–∞–Ω–Ω—ã–µ
    raw_data = {
        'user_agent': request.META.get('HTTP_USER_AGENT', ''),
        'referer': request.META.get('HTTP_REFERER', ''),
        'host': request.get_host(),
        'method': request.method,
        'path': request.path,
        'auth_param': request.GET.get('_auth') or request.POST.get('_auth'),
        'tgWebAppData': request.GET.get('tgWebAppData') or request.POST.get('tgWebAppData'),
    }
    diagnosis['raw_data'] = raw_data

    # –ü—ã—Ç–∞–µ–º—Å—è —Ä–∞—Å–ø–∞—Ä—Å–∏—Ç—å –¥–∞–Ω–Ω—ã–µ
    init_data = raw_data['auth_param'] or raw_data['tgWebAppData']
    if init_data:
        try:
            from .telegram_auth import parse_telegram_webapp_data
            parsed_data = parse_telegram_webapp_data(init_data)
            if parsed_data:
                diagnosis['parsed_data'] = {
                    'user_id': parsed_data.get('id'),
                    'username': parsed_data.get('username'),
                    'first_name': parsed_data.get('first_name'),
                    'last_name': parsed_data.get('last_name'),
                }
        except Exception as e:
            diagnosis['errors'].append(f"Failed to parse Telegram data: {e}")

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é
    config_issues = []
    try:
        from django.conf import settings
        if not getattr(settings, 'TELEGRAM_BOT_TOKEN', ''):
            config_issues.append("TELEGRAM_BOT_TOKEN not configured")
        if not getattr(settings, 'TELEGRAM_MINIAPP_URL', ''):
            config_issues.append("TELEGRAM_MINIAPP_URL not configured")
    except ImportError:
        config_issues.append("Django settings not available")

    if config_issues:
        diagnosis['errors'].extend(config_issues)

    # –†–µ–∫–æ–º–µ–Ω–¥–∞—Ü–∏–∏
    recommendations = []
    if not diagnosis['is_telegram_request']:
        recommendations.append(
            "Request doesn't appear to be from Telegram WebApp")
    if not init_data:
        recommendations.append("No Telegram WebApp data found in request")
    if config_issues:
        recommendations.append("Check Telegram bot configuration")

    diagnosis['recommendations'] = recommendations

    return diagnosis


def log_telegram_request(request, level: str = 'INFO') -> None:
    """
    –õ–æ–≥–∏—Ä—É–µ—Ç –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏—é –æ Telegram WebApp –∑–∞–ø—Ä–æ—Å–µ

    Args:
        request: HTTP –∑–∞–ø—Ä–æ—Å
        level: –£—Ä–æ–≤–µ–Ω—å –ª–æ–≥–∏—Ä–æ–≤–∞–Ω–∏—è
    """
    diagnosis = diagnose_telegram_request(request)

    log_data = {
        'path': request.path,
        'method': request.method,
        'host': request.get_host(),
        'is_telegram_request': diagnosis['is_telegram_request'],
        'user_agent': request.META.get('HTTP_USER_AGENT', ''),
        'has_auth_data': bool(diagnosis['raw_data']['auth_param']),
        'has_tgWebAppData': bool(diagnosis['raw_data']['tgWebAppData']),
        'user_id': diagnosis['parsed_data'].get('user_id'),
        'errors': diagnosis['errors'],
    }

    if level.upper() == 'ERROR':
        logger.error(f"Telegram request error: {json.dumps(log_data)}")
    elif level.upper() == 'WARNING':
        logger.warning(f"Telegram request warning: {json.dumps(log_data)}")
    else:
        logger.info(f"Telegram request: {json.dumps(log_data)}")


def validate_telegram_config() -> Dict[str, Any]:
    """
    –ü—Ä–æ–≤–µ—Ä—è–µ—Ç –∫–æ–Ω—Ñ–∏–≥—É—Ä–∞—Ü–∏—é Telegram –±–æ—Ç–∞

    Returns:
        Dict —Å —Ä–µ–∑—É–ª—å—Ç–∞—Ç–∞–º–∏ –ø—Ä–æ–≤–µ—Ä–∫–∏
    """
    validation = {
        'valid': True,
        'issues': [],
        'warnings': [],
        'config': {}
    }

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –æ—Å–Ω–æ–≤–Ω—ã–µ –Ω–∞—Å—Ç—Ä–æ–π–∫–∏
    try:
        from django.conf import settings
        bot_token = getattr(settings, 'TELEGRAM_BOT_TOKEN', '')
        miniapp_url = getattr(settings, 'TELEGRAM_MINIAPP_URL', '')
        debug_mode = getattr(settings, 'TELEGRAM_MINIAPP_DEBUG_MODE', False)
        allowed_hosts = getattr(settings, 'ALLOWED_HOSTS', [])
    except ImportError:
        bot_token = ''
        miniapp_url = ''
        debug_mode = False
        allowed_hosts = []

    validation['config'] = {
        'bot_token_configured': bool(bot_token),
        'miniapp_url_configured': bool(miniapp_url),
        'debug_mode': debug_mode,
        'allowed_hosts': allowed_hosts,
    }

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–æ–±–ª–µ–º—ã
    if not bot_token:
        validation['issues'].append("TELEGRAM_BOT_TOKEN not configured")
        validation['valid'] = False

    if not miniapp_url:
        validation['issues'].append("TELEGRAM_MINIAPP_URL not configured")
        validation['valid'] = False

    # –ü—Ä–æ–≤–µ—Ä—è–µ–º –ø—Ä–µ–¥—É–ø—Ä–µ–∂–¥–µ–Ω–∏—è
    if debug_mode:
        validation['warnings'].append(
            "Debug mode is enabled - this should be disabled in production")

    if '*' in allowed_hosts:
        validation['warnings'].append(
            "ALLOWED_HOSTS contains '*' - this is insecure")

    return validation


def get_telegram_error_response(error_type: str, message: str = None) -> Dict[str, Any]:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —Å—Ç–∞–Ω–¥–∞—Ä—Ç–∏–∑–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –æ—Ç–≤–µ—Ç –æ–± –æ—à–∏–±–∫–µ –¥–ª—è Telegram WebApp

    Args:
        error_type: –¢–∏–ø –æ—à–∏–±–∫–∏
        message: –î–æ–ø–æ–ª–Ω–∏—Ç–µ–ª—å–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ

    Returns:
        Dict —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ–± –æ—à–∏–±–∫–µ
    """
    error_responses = {
        'unauthorized': {
            'error': 'Unauthorized',
            'message': message or 'Access denied. Please open this app from Telegram.',
            'code': 401
        },
        'invalid_data': {
            'error': 'Invalid Data',
            'message': message or 'Invalid Telegram WebApp data received.',
            'code': 400
        },
        'user_not_found': {
            'error': 'User Not Found',
            'message': message or 'User authentication failed.',
            'code': 401
        },
        'server_error': {
            'error': 'Server Error',
            'message': message or 'An internal server error occurred.',
            'code': 500
        },
        'not_found': {
            'error': 'Not Found',
            'message': message or 'The requested resource was not found.',
            'code': 404
        }
    }

    return error_responses.get(error_type, error_responses['server_error'])


def format_balance(amount: float) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Å—É–º–º—É –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Telegram

    Args:
        amount: –°—É–º–º–∞ –¥–ª—è —Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–∏—è

    Returns:
        –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Å —Å—É–º–º–æ–π
    """
    if amount is None:
        return "0.00"

    # –û–∫—Ä—É–≥–ª—è–µ–º –¥–æ 2 –∑–Ω–∞–∫–æ–≤ –ø–æ—Å–ª–µ –∑–∞–ø—è—Ç–æ–π
    formatted_amount = round(float(amount), 2)

    # –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ–º —Å —Ä–∞–∑–¥–µ–ª–∏—Ç–µ–ª—è–º–∏ —Ç—ã—Å—è—á
    if formatted_amount >= 1000:
        return f"{formatted_amount:,.2f}".replace(',', ' ')
    else:
        return f"{formatted_amount:.2f}"


def format_transaction(transaction) -> str:
    """
    –§–æ—Ä–º–∞—Ç–∏—Ä—É–µ—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏—é –¥–ª—è –æ—Ç–æ–±—Ä–∞–∂–µ–Ω–∏—è –≤ Telegram

    Args:
        transaction: –û–±—ä–µ–∫—Ç —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏

    Returns:
        –û—Ç—Ñ–æ—Ä–º–∞—Ç–∏—Ä–æ–≤–∞–Ω–Ω–∞—è —Å—Ç—Ä–æ–∫–∞ —Å –∏–Ω—Ñ–æ—Ä–º–∞—Ü–∏–µ–π –æ —Ç—Ä–∞–Ω–∑–∞–∫—Ü–∏–∏
    """
    if not transaction:
        return "–¢—Ä–∞–Ω–∑–∞–∫—Ü–∏—è –Ω–µ –Ω–∞–π–¥–µ–Ω–∞"

    transaction_type = "üìà –î–æ—Ö–æ–¥" if transaction.t_type == 'IN' else "üìâ –†–∞—Å—Ö–æ–¥"
    amount = format_balance(transaction.amount)
    currency = transaction.wallet.currency.char_code if transaction.wallet and transaction.wallet.currency else "RUB"

    result = f"{transaction_type}: {amount} {currency}"

    if transaction.description:
        result += f"\nüìù {transaction.description}"

    if transaction.category:
        result += f"\nüè∑Ô∏è {transaction.category.title}"

    if transaction.wallet:
        result += f"\nüí∞ {transaction.wallet.title}"

    return result


def validate_amount(amount_str: str) -> tuple:
    """
    –í–∞–ª–∏–¥–∏—Ä—É–µ—Ç —Å—É–º–º—É, –≤–≤–µ–¥–µ–Ω–Ω—É—é –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–º

    Args:
        amount_str: –°—Ç—Ä–æ–∫–∞ —Å —Å—É–º–º–æ–π

    Returns:
        Tuple (is_valid, amount, error_message)
    """
    if not amount_str:
        return False, 0.0, "–°—É–º–º–∞ –Ω–µ –º–æ–∂–µ—Ç –±—ã—Ç—å –ø—É—Å—Ç–æ–π"

    try:
        # –ó–∞–º–µ–Ω—è–µ–º –∑–∞–ø—è—Ç—É—é –Ω–∞ —Ç–æ—á–∫—É –¥–ª—è –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ–≥–æ –ø–∞—Ä—Å–∏–Ω–≥–∞
        amount_str = amount_str.replace(',', '.')
        amount = float(amount_str)

        if amount <= 0:
            return False, 0.0, "–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –±–æ–ª—å—à–µ –Ω—É–ª—è"

        if amount > 999999999:
            return False, 0.0, "–°—É–º–º–∞ —Å–ª–∏—à–∫–æ–º –±–æ–ª—å—à–∞—è"

        return True, amount, ""

    except ValueError:
        return False, 0.0, "–ù–µ–≤–µ—Ä–Ω—ã–π —Ñ–æ—Ä–º–∞—Ç —Å—É–º–º—ã. –ò—Å–ø–æ–ª—å–∑—É–π—Ç–µ —á–∏—Å–ª–∞, –Ω–∞–ø—Ä–∏–º–µ—Ä: 1000 –∏–ª–∏ 1000.50"


def get_currency_emoji(currency_code: str) -> str:
    """
    –í–æ–∑–≤—Ä–∞—â–∞–µ—Ç —ç–º–æ–¥–∑–∏ –¥–ª—è –≤–∞–ª—é—Ç—ã

    Args:
        currency_code: –ö–æ–¥ –≤–∞–ª—é—Ç—ã

    Returns:
        –≠–º–æ–¥–∑–∏ –≤–∞–ª—é—Ç—ã
    """
    currency_emojis = {
        'RUB': 'üá∑üá∫',
        'USD': 'üá∫üá∏',
        'EUR': 'üá™üá∫',
        'GBP': 'üá¨üáß',
        'CNY': 'üá®üá≥',
        'JPY': 'üáØüáµ',
        'KZT': 'üá∞üáø',
        'BYN': 'üáßüáæ',
        'UAH': 'üá∫üá¶',
        'AMD': 'üá¶üá≤',
        'AZN': 'üá¶üáø',
        'GEL': 'üá¨üá™',
        'KGS': 'üá∞üá¨',
        'MDL': 'üá≤üá©',
        'TJS': 'üáπüáØ',
        'TMT': 'üáπüá≤',
        'UZS': 'üá∫üáø',
    }

    return currency_emojis.get(currency_code.upper(), 'üí±')
